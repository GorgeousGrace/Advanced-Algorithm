import time
import mmh3
import math
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import List
# Optimized Cuckoo Filter and Bloom Filter are generated by GenAI
# Please check the output with "final_result.png"
# ---------------------- Optimized Data Structures ----------------------

class LinearSearchChecker:
    def __init__(self) -> None:
        self.logins: List[int] = []

    def insert(self, login: int) -> None:
        self.logins.append(login)

    def check(self, login: int) -> bool:
        return login in self.logins

class BinarySearchChecker:
    def __init__(self) -> None:
        self.logins: List[int] = []

    def insert(self, login: int) -> None:
        self.logins.append(login)

    def prepare(self) -> None:
        """ Sorts the list after all insertions. """
        self.logins.sort()

    def check(self, login: int) -> bool:
        low, high = 0, len(self.logins) - 1
        while low <= high:
            mid = (low + high) // 2
            if self.logins[mid] == login:
                return True
            elif self.logins[mid] < login:
                low = mid + 1
            else:
                high = mid - 1
        return False

class HashTable:
    def __init__(self) -> None:
        self.table = set()

    def insert(self, login: int) -> None:
        self.table.add(login)

    def check(self, login: int) -> bool:
        return login in self.table

class OptimizedBloomFilter:
    def __init__(self, n: int, fp_rate: float = 0.01):
        self.m = int(-n * math.log(fp_rate) / (math.log(2)**2))
        self.k = max(7, int((self.m / n) * math.log(2)))  # At least 7 hash functions
        self.bit_array = np.zeros(self.m, dtype=bool)

    def _hash(self, login: int, seed: int) -> int:
        hash_val = mmh3.hash(str(login), seed)
        return (hash_val + seed * 31) % self.m

    def insert(self, login: int) -> None:
        for i in range(self.k):
            self.bit_array[self._hash(login, i)] = True

    def check(self, login: int) -> bool:
        return all(self.bit_array[self._hash(login, i)] for i in range(self.k))

class UltraFastCuckooFilter:
    def __init__(self, capacity: int, bucket_size: int = 10):
        self.capacity = int(4 * capacity)  # Expand capacity to reduce rehashing
        self.bucket_size = bucket_size
        self.buckets = [bytearray(bucket_size) for _ in range(self.capacity)]

    def _fingerprint(self, login: int) -> int:
        return mmh3.hash(str(login)) & 0b11111  # 5-bit fingerprint for faster lookup

    def _hash1(self, login: int) -> int:
        return mmh3.hash(str(login)) % self.capacity

    def _hash2(self, fingerprint: int) -> int:
        return (self.capacity - 1) - (fingerprint % (self.capacity - 1))

    def insert(self, login: int) -> bool:
        fp = self._fingerprint(login)
        i1, i2 = self._hash1(login), self._hash2(fp)
        return self._insert(fp, i1) or self._insert(fp, i2)

    def _insert(self, fp: int, index: int) -> bool:
        for idx in range(self.bucket_size):
            if self.buckets[index][idx] == 0:
                self.buckets[index][idx] = fp
                return True
        return False  # No space available

    def check(self, login: int) -> bool:
        fp = self._fingerprint(login)
        i1, i2 = self._hash1(login), self._hash2(fp)
        return fp in self.buckets[i1] or fp in self.buckets[i2]

# ---------------------- Benchmark Setup ----------------------

def generate_logins(n: int) -> List[int]:
    return list(range(n))

def measure_time(checker, test_login: int, reps: int = 1_000) -> float:
    total = 0
    for _ in range(reps):
        start = time.perf_counter_ns()
        checker.check(test_login)
        total += time.perf_counter_ns() - start
    return (total / reps) / 1e6

def benchmark():
    test_sizes = [100_000, 500_000, 1_000_000, 5_000_000, 10_000_000]
    results = {
        'Linear': [], 'Binary': [], 'Hash': [],
        'Bloom': [], 'Cuckoo': []
    }

    linear_time_100K = None  # Store Linear Search time at 100K

    for n in test_sizes:
        logins = generate_logins(n)
        test_login = -1

        print(f"Testing n={n:,}...")

        # Linear Search (Estimate for Large Sizes)
        if n == 100_000:
            linear = LinearSearchChecker()
            for x in logins[:100_000]:
                linear.insert(x)
            time_taken = measure_time(linear, test_login)
            results['Linear'].append(time_taken)
            linear_time_100K = time_taken  # Save for extrapolation
        elif linear_time_100K:
            # Estimate T(n) = T(100K) * (n / 100K)
            estimated_time = linear_time_100K * (n / 100_000)
            results['Linear'].append(estimated_time)
        else:
            results['Linear'].append(None)

        # Binary Search
        binary = BinarySearchChecker()
        for x in logins:
            binary.insert(x)
        binary.prepare()
        results['Binary'].append(measure_time(binary, test_login))

        # Hash Table
        ht = HashTable()
        for x in logins:
            ht.insert(x)
        results['Hash'].append(measure_time(ht, test_login))

        # Optimized Bloom Filter
        bf = OptimizedBloomFilter(n)
        for x in logins:
            bf.insert(x)
        results['Bloom'].append(measure_time(bf, test_login))

        # Ultra-Fast Cuckoo Filter
        cf = UltraFastCuckooFilter(capacity=n)
        for x in logins:
            cf.insert(x)
        results['Cuckoo'].append(measure_time(cf, test_login))

    # ---------------------- Generate Plot ----------------------
    plt.figure(figsize=(12, 7))
    sns.set(style="whitegrid")

    markers = ['o', 's', '^', 'D', 'v']
    for (algo, marker) in zip(results.items(), markers):
        plt.plot(test_sizes, algo[1], marker=marker, label=algo[0], linewidth=2)

    plt.xscale('log')
    plt.yscale('log')
    plt.xticks(test_sizes, labels=[f"{x//1_000}" + "K" if x < 1_000_000 else f"{x//1_000_000}M" for x in test_sizes])
    plt.xlabel('Number of Users', fontsize=12, fontweight='bold')
    plt.ylabel('Time per Check (ms)', fontsize=12, fontweight='bold')
    plt.title('Login Check Performance', fontsize=14, fontweight='bold')
    plt.legend()
    plt.grid(True, which="both", linestyle="--", linewidth=0.5)

    plt.savefig('final_result.png', dpi=300)
    plt.show()

if __name__ == '__main__':
    benchmark()
